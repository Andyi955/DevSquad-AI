--- AGENT REPORT ---
Agent: Junior Dev
Timestamp: 2026-02-10T17:57:15.702708
Content:
THOUGHTS:

Task: Implement core game logic (Snake class, movement, food spawning, collision detection).
Files needed: `game_logic.py`
Approach:
1. Create a `Direction` Enum for readability.
2. Implement a `Snake` class to manage the body segments and movement.
3. Implement a `Food` class to handle random spawning within bounds.
4. Implement a `GameState` class to orchestrate the game rules (collisions, scoring, game over state).
5. Ensure the logic is independent of `curses` for easier testing.


RESPONSE:


I have implemented the core game logic in `game_logic.py`. This includes the `Snake` and `Food` classes, along with a `GameState` manager that handles movement, collisions, and scoring. The logic uses a `(y, x)` coordinate system to align with `curses` conventions.

[CREATE_FILE:game_logic.py]
```python
import random
from enum import Enum
from typing import List, Tuple, Optional

class Direction(Enum):
    UP = (-1, 0)
    DOWN = (1, 0)
    LEFT = (0, -1)
    RIGHT = (0, 1)

class Snake:
    def __init__(self, start_pos: Tuple[int, int]):
        # Initial snake: head at start_pos, and two segments to the left
        y, x = start_pos
        self.body = [(y, x), (y, x - 1), (y, x - 2)]
        self.direction = Direction.RIGHT
        self.grow_pending = False

    @property
    def head(self) -> Tuple[int, int]:
        return self.body[0]

    def change_direction(self, new_direction: Direction):
        # Prevent 180-degree turns
        if (new_direction.value[0] + self.direction.value[0] == 0 and
            new_direction.value[1] + self.direction.value[1] == 0):
            return
        self.direction = new_direction

    def move(self):
        new_head = (
            self.head[0] + self.direction.value[0],
            self.head[1] + self.direction.value[1]
        )
        self.body.insert(0, new_head)
        
        if not self.grow_pending:
            self.body.pop()
        else:
            self.grow_pending = False

    def grow(self):
        self.grow_pending = True

    def collides_with_self(self) -> bool:
        return self.head in self.body[1:]

class Food:
    def __init__(self, max_y: int, max_x: int, forbidden_positions: List[Tuple[int, int]]):
        self.position = (0, 0)
        self.spawn(max_y, max_x, forbidden_positions)

    def spawn(self, max_y: int, max_x: int, forbidden_positions: List[Tuple[int, int]]):
        while True:
            # Leave a 1-cell margin for borders
            new_pos = (random.randint(1, max_y - 2), random.randint(1, max_x - 2))
            if new_pos not in forbidden_positions:
                self.position = new_pos
                break

class GameState:
    def __init__(self, height: int, width: int):
        self.height = height
        self.width = width
        self.snake = Snake((height // 2, width // 2))
        self.food = Food(height, width, self.snake.body)
        self.score = 0
        self.game_over = False

    def update(self):
        if self.game_over:
            return

        self.snake.move()

        # Check wall collision
        head_y, head_x = self.snake.head
        if not (0 < head_y < self.height - 1 and 0 < head_x < self.width - 1):
            self.game_over = True
            return

        # Check self collision
        if self.snake.collides_with_self():
            self.game_over = True
            return

        # Check food collision
        if self.snake.head == self.food.position:
            self.snake.grow()
            self.score += 10
            self.food.spawn(self.height, self.width, self.snake.body)
```

[CHECKLIST_UPDATE]
- [x] 3. Implement core game logic including Snake class, movement, food spawning, and collision detection (→JUNIOR)
[/CHECKLIST_UPDATE]

[→SENIOR] Core game logic is implemented in `game_logic.py`. It includes `Snake`, `Food`, and `GameState` classes. The logic is decoupled from the UI and uses `(y, x)` coordinates. Ready for the UI implementation or testing.
[DONE]
